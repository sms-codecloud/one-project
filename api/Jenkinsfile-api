pipeline {
  agent { label 'win-dev' }

  options { timestamps(); ansiColor('xterm'); disableConcurrentBuilds() }

  parameters {
    string(name: 'PROJECT_REL', defaultValue: 'api', description: 'Path within repo to the API project or folder')
    choice(name: 'CONFIG', choices: ['Release','Debug'], description: 'Build configuration')
    booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run tests')
    string(name: 'AWS_REGION', defaultValue: 'ap-south-1', description: 'AWS region')
    string(name: 'AWS_CREDS_ID', defaultValue: 'aws_secrets_shankar', description: 'Jenkins AWS creds ID')
    string(name: 'EC2_INSTANCE_ID', defaultValue: '', description: 'Target Windows EC2 instance id (SSM)')
    string(name: 'MYSQL_APP_PASSWORD_CRED_ID', defaultValue: 'mysql_app_password', description: 'Secret Text credential ID for MySQL app password (prod)')
  }

  environment {
    DOTNET_CLI_TELEMETRY_OPTOUT       = '1'
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE = '1'
    CLONE_ROOT   = 'D:\\jenkins-workspace\\workspace'
    BUILD_DIR    = "${CLONE_ROOT}\\${JOB_NAME}\\${BUILD_NUMBER}"
    PUBLISH_DIR  = 'publish'
    ARTIFACT_ZIP = 'student-api.zip'
    S3_BUCKET    = 'arj-bootcamp'                   // set once here
    S3_KEY       = "api/student-api-${BUILD_NUMBER}.zip" // latest build-numbered key
  }

  stages {
    stage('Resolve SCM (URL & Branch)') {
      steps {
        script {
          def cfg = null
          try { cfg = scm.getUserRemoteConfigs() } catch (ignored) {}
          if (!cfg || cfg.isEmpty()) { error "Could not read userRemoteConfigs from job SCM. Configure SCM in the job." }
          env._GIT_URL = cfg[0].getUrl()

          def br = env.BRANCH_NAME ?: ''
          if (!br?.trim()) {
            try {
              def branches = scm.getBranches()
              if (branches && branches.size() > 0) { br = branches[0].getName() }
            } catch (ignored) {}
          }
          if (!br?.trim()) { error "Could not determine branch from job SCM (BRANCH_NAME or scm.getBranches())." }
          env._BRANCH = br.replaceFirst('^\\*/', '')
          echo "SCM URL: ${env._GIT_URL}"
          echo "SCM Branch: ${env._BRANCH}"
        }
      }
    }

    stage('Prepare clean external build folder') {
      steps {
        powershell '''
          $ErrorActionPreference = "Stop"
          if (Test-Path $env:BUILD_DIR) { Remove-Item -Recurse -Force $env:BUILD_DIR }
          New-Item -ItemType Directory -Force -Path $env:BUILD_DIR | Out-Null
        '''
      }
    }

    stage('Clone into external directory') {
      steps {
        dir("${env.BUILD_DIR}") {
          bat """
            @echo on
            git --version
            git clone --branch "%_BRANCH%" --depth 1 "%_GIT_URL%" repo
          """
        }
      }
    }

  stage('Restore & Build (local validation)') {
    steps {
      dir("${env.BUILD_DIR}\\repo") {
        powershell '''
          $ErrorActionPreference = "Stop"

          # 0) Show where we are + helpful listing
          Write-Host "Repo root: $((Get-Location).Path)"
          Write-Host "PROJECT_REL: ${env:PROJECT_REL}"
          if (!(Test-Path "${env:PROJECT_REL}")) {
            Write-Host 'Contents of repo root:'
            Get-ChildItem -Force
            throw 'PROJECT_REL path does not exist. Fix the parameter so it points under the repo root.'
          }

          $base = Join-Path (Get-Location) "${env:PROJECT_REL}"

          # 1) Find a solution or project inside PROJECT_REL (prefer .sln)
          $sln = Get-ChildItem -Path $base -Recurse -Filter *.sln | Select-Object -First 1
          $csproj = $null
          if (-not $sln) {
            $csproj = Get-ChildItem -Path $base -Recurse -Filter *.csproj | Select-Object -First 1
          }

          if ($sln) {
            Write-Host "Using solution: $($sln.FullName)"
            dotnet --info
            dotnet restore "$($sln.FullName)"
            dotnet build "$($sln.FullName)" -c ${env:CONFIG} --no-restore
          } elseif ($csproj) {
            Write-Host "Using project: $($csproj.FullName)"
            dotnet --info
            dotnet restore "$($csproj.FullName)"
            dotnet build "$($csproj.FullName)" -c ${env:CONFIG} --no-restore
          } else {
            Write-Host "Listing of PROJECT_REL:"; Get-ChildItem -Recurse -Force -Path $base
            throw 'No .sln or .csproj found under PROJECT_REL. Adjust PROJECT_REL to the folder that contains your .sln/.csproj.'
          }
        '''
      }
    }
  }



    stage('Test') {
      when { expression { return params.RUN_TESTS } }
      steps {
        dir("${env.BUILD_DIR}\\repo") {
          powershell '''
            $ErrorActionPreference = "Stop"
            $tests = Get-ChildItem -Recurse -Filter *.csproj | Where-Object { $_.FullName -match '(?i)test|tests' }
            if ($tests) {
              foreach ($t in $tests) {
                dotnet test $t.FullName -c $env:CONFIG --no-build --logger "trx;LogFileName=TestResults.trx"
              }
            } else { Write-Host "No tests found." }
          '''
        }
      }
      post { always { junit allowEmptyResults: true, testResults: '**/TestResults/*.xml' } }
    }

stage('Publish & Package') {
  steps {
    dir("${env.BUILD_DIR}\\repo") {
      powershell """
        $ErrorActionPreference = 'Stop'
        $base = Join-Path (Get-Location) '${params.PROJECT_REL}'
        $proj = Get-ChildItem -Path $base -Recurse -Filter *.csproj | Select-Object -First 1
        if (-not $proj) { throw 'No .csproj found for publish.' }

        $projDir = Split-Path -Parent $proj.FullName
        Set-Location $projDir

        if (Test-Path '${env:PUBLISH_DIR}') { Remove-Item -Recurse -Force '${env:PUBLISH_DIR}' }
        dotnet publish "$($proj.FullName)" -c ${params.CONFIG} -o '${env:PUBLISH_DIR}' --no-restore

        Set-Location '${env:PUBLISH_DIR}'
        if (!(Test-Path '*.dll')) { throw 'No DLLs in publish output; publish likely failed.' }

        $zip = Join-Path '${env:BUILD_DIR}' '${env:ARTIFACT_ZIP}'
        if (Test-Path $zip) { Remove-Item -Force $zip }
        Compress-Archive -Path * -DestinationPath $zip
        Write-Host "Packaged: $zip"
      """
    }
  }
}


    stage('Upload to S3') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: params.AWS_CREDS_ID]]) {
          dir("${env.BUILD_DIR}") {
            powershell """
              \$ErrorActionPreference = 'Stop'
              aws --version
              if (!(Test-Path '${env.ARTIFACT_ZIP}')) { throw 'Artifact zip missing.' }
              aws s3 cp '${env.ARTIFACT_ZIP}' s3://${env.S3_BUCKET}/${env.S3_KEY} --region ${params.AWS_REGION} --only-show-errors
            """
          }
        }
      }
    }

    stage('Deploy via SSM (script from repo)') {
      steps {
        withCredentials([
          [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: params.AWS_CREDS_ID],
          string(credentialsId: "${params.MYSQL_APP_PASSWORD_CRED_ID}", variable: 'MYSQL_APP_PASSWORD')
        ]) {
          dir("${env.BUILD_DIR}\\repo\\${params.PROJECT_REL}") {
            powershell """
              \$ErrorActionPreference = 'Stop'
              \$script = Join-Path (Get-Location) 'deploy-api-ssm.ps1'
              if (!(Test-Path \$script)) { throw "deploy-api-ssm.ps1 not found at \$script" }

              powershell -ExecutionPolicy Bypass -File "\$script" `
                -InstanceId "${params.EC2_INSTANCE_ID}" `
                -Region     "${params.AWS_REGION}" `
                -Bucket     "${env.S3_BUCKET}" `
                -Key        "${env.S3_KEY}" `
                -MySQLAppPassword "$env:MYSQL_APP_PASSWORD"
            """
          }
        }
      }
    }

    stage('Summary') {
      steps {
        echo "Built & tested from: ${env.BUILD_DIR}"
        echo "Uploaded ${env.ARTIFACT_ZIP} to s3://${env.S3_BUCKET}/${env.S3_KEY} (${params.AWS_REGION})"
        echo "Deployed to EC2 (SSM): ${params.EC2_INSTANCE_ID}"
      }
    }
  }

  post {
    always {
      powershell '''
        $ErrorActionPreference = "SilentlyContinue"
        if (Test-Path "$env:BUILD_DIR") { Remove-Item -Recurse -Force "$env:BUILD_DIR" }
      '''
    }
    failure { echo "Build failed. Check console logs." }
  }
}
