pipeline {
  agent { label 'win-dev' }
  options { disableConcurrentBuilds(); timestamps() }

  parameters {
    choice(name: 'TF_ACTION', choices: ['APPLY','DESTROY'], description: 'Terraform action')
    // Comma-separated Secret Text credential IDs. Each secretâ€™s VALUE must be a CIDR like 49.207.145.12/32
    string(name: 'CIDR_CRED_IDS', defaultValue: 'shankar_ip_cidr,mahantesh_ip_cidr,sharanu_ip_cidr', description: 'Comma-separated Jenkins Secret Text credential IDs that each contain one CIDR.')
  }

  environment {
    TF_IN_AUTOMATION = "true"
    TF_DIR = 'infra'
    PATH = "C:\\binaries\\terraform;${env.PATH}"  // ensure terraform.exe in PATH
  }

  stages {
    stage('Tool Versions') {
      steps {
        bat 'git --version'
        bat 'terraform --version'
        bat 'node --version'
        bat 'dotnet --version'
      }
    }

    stage('Checkout Repo') {
      steps {
        cleanWs()
        checkout scm
        bat 'dir /s /b *.csproj || ver >NUL'
      }
    }

    stage('Bind CIDR Secrets -> TF_VARs') {
      steps {
        script {
          // Build a dynamic credential binding list for the provided secret IDs
          def ids = params.CIDR_CRED_IDS.split(',')*.trim().findAll { it }
          if (ids.isEmpty()) { error "No CIDR credential IDs provided." }

          def bindings = []
          ids.eachWithIndex { id, i ->
            bindings << [$class: 'StringBinding', credentialsId: id, variable: "CIDR_${i}"]
          }
          // Also bind the SQL SA password
          bindings << [$class: 'StringBinding', credentialsId: 'sql_sa_password', variable: 'SQL_SA_PASSWORD']

          withCredentials(bindings) {
            def cidrs = []
            ids.eachWithIndex { id, i ->
              def v = (env["CIDR_${i}"] ?: '').trim()
              if (!v) { error "Credential '${id}' is empty." }
              // simple IPv4 CIDR regex; Terraform will further validate
              if (!(v ==~ /(?:\d{1,3}\.){3}\d{1,3}\/(?:3[0-2]|[12]?\d)/)) {
                error "Credential '${id}' value '${v}' is not a valid CIDR (e.g. 203.0.113.10/32)."
              }
              cidrs << v
            }

            // Export to Terraform as a JSON list(string)
            env.TF_VAR_allowed_ssh_cidrs = new groovy.json.JsonBuilder(cidrs).toString()
            // Export SQL password
            env.TF_VAR_sql_sa_password   = env.SQL_SA_PASSWORD

            echo "Loaded ${cidrs.size()} SSH CIDR(s) for allow-list."
          }
        }
      }
    }

    stage('Sanity (no stray tfvars)') {
      steps {
        dir("${env.WORKSPACE}\\${env.TF_DIR}") {
          powershell '''
            $ErrorActionPreference = "Stop"
            Write-Host "Auto-loaded tfvars files present (should be none):"
            Get-ChildItem -Force -Name *.tfvars,*.auto.tfvars,*.tfvars.json,*.auto.tfvars.json -ErrorAction SilentlyContinue | ForEach-Object { "  - $_" }
            if (-not $env:TF_VAR_allowed_ssh_cidrs) { throw "TF_VAR_allowed_ssh_cidrs not set"; }
            if (-not $env:TF_VAR_sql_sa_password)   { throw "TF_VAR_sql_sa_password not set"; }
          '''
        }
      }
    }

    stage('Terraform Init & Run') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_secrets_shankar']]) {
          dir("${env.WORKSPACE}\\${env.TF_DIR}") {
            powershell '''
              $ErrorActionPreference = "Stop"
              terraform init -reconfigure -upgrade -no-color -input=false

              if ($env:TF_ACTION -eq "DESTROY") {
                terraform plan  -destroy -out=tfplan -no-color -input=false
                terraform apply -no-color -input=false -auto-approve tfplan
              } else {
                terraform plan  -out=tfplan -no-color -input=false
                terraform apply -no-color -input=false -auto-approve tfplan
                terraform output
                terraform output -json | Out-File -FilePath tf-outputs.json -Encoding utf8
              }
            '''
          }
        }
      }
    }
  }

  post {
    always {
      archiveArtifacts artifacts: "${TF_DIR}\\tfplan, ${TF_DIR}\\tf-outputs.json", allowEmptyArchive: true
      cleanWs()
    }
  }
}
