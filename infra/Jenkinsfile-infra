pipeline {
  agent { label 'win-dev' }
  options { disableConcurrentBuilds(); timestamps() }

  parameters {
    choice(name: 'TF_ACTION', choices: ['APPLY','DESTROY'], description: 'Terraform action')
    string(name: 'CIDR_CRED_IDS', defaultValue: 'shankar_ip_cidr', description: 'Comma-separated Secret Text credential IDs; each contains a CIDR like 1.2.3.4/32')
    string(name: 'MYSQL_APP_PASSWORD_ID', defaultValue: 'mysql_app_password', description: 'Secret Text credential ID for MySQL app password')
  }

  environment {
    TF_IN_AUTOMATION = 'true'
    TF_DIR = 'infra'
    PATH   = "C:\\binaries\\terraform;${env.PATH}"
  }

  stages {
    stage('Checkout') { steps { checkout scm } }

    stage('Bind Secrets â†’ JSON') {
      steps {
        script {
          // Parse CIDR secret IDs
          def raw = params.CIDR_CRED_IDS.tokenize(',')
          def ids = []; for (r in raw) { def t=r.trim(); if (t) ids<<t }
          if (ids.isEmpty()) error 'No CIDR credential IDs provided.'

          // Build the bindings list
          def bindings = []
          for (int i=0; i<ids.size(); i++) {
            bindings << [$class:'StringBinding', credentialsId: ids[i], variable: "CIDR_${i}"]
          }
          // Add MySQL secret (parameterized)
          def mysqlCredId = (params.MYSQL_APP_PASSWORD_ID ?: '').trim()
          if (!mysqlCredId) { error 'MYSQL_APP_PASSWORD_ID parameter is empty.' }
          bindings << [$class:'StringBinding', credentialsId: mysqlCredId, variable:'MYSQL_APP_PASSWORD']

          // Try binding; if the ID is wrong/missing Jenkins will throw here
          withCredentials(bindings) {
            // Build JSON array of CIDRs
            def cidrJson = powershell(returnStdout: true, script: '''
              $ErrorActionPreference = "Stop"
              $cidrs=@(); $i=0
              while ($true) {
                $name="CIDR_$i"; $val=[Environment]::GetEnvironmentVariable($name)
                if ([string]::IsNullOrWhiteSpace($val)) { break }
                $val=$val.Trim()
                if (-not ($val -match "^\\d{1,3}(\\.\\d{1,3}){3}/(?:3[0-2]|[12]?\\d)$")) {
                  throw ("Invalid CIDR in {0}: {1} (expected 203.0.113.10/32)" -f $name,$val)
                }
                $cidrs+=$val; $i++
              }
              if ($cidrs.Count -eq 0) { throw "No CIDRs found" }
              ($cidrs | ConvertTo-Json -Compress)
            ''').trim()

            env.ALLOWED_CIDRS_JSON         = cidrJson
            env.TF_VAR_mysql_app_password  = env.MYSQL_APP_PASSWORD

            echo "Prepared ${ids.size()} SSH CIDR(s)."
          }
        }
      }
    }

    stage('Terraform Init & Run') {
      steps {
        withCredentials([[$class:'AmazonWebServicesCredentialsBinding', credentialsId:'aws_secrets_shankar']]) {
          dir("${env.WORKSPACE}\\${env.TF_DIR}") {
            powershell '''
              $ErrorActionPreference="Stop"
              if (-not $env:ALLOWED_CIDRS_JSON) { throw "ALLOWED_CIDRS_JSON not set" }
              $json = $env:ALLOWED_CIDRS_JSON.Trim()
              if ($json -notmatch '^[\\[]') { $json = '["' + $json.Trim('"') + '"]' }
              $content = '{ "allowed_ssh_cidrs": ' + $json + ' }'
              $enc = New-Object System.Text.UTF8Encoding($false)
              [System.IO.File]::WriteAllText("cidrs.auto.tfvars.json", $content, $enc)
              Write-Host "cidrs.auto.tfvars.json: $content"
            '''
            powershell '''
              $ErrorActionPreference="Stop"
              $action = ($env:TF_ACTION | ForEach-Object { $_.Trim().ToUpperInvariant() })
              if (Test-Path tfplan) { Remove-Item -Force tfplan }

              terraform init -reconfigure -upgrade -no-color -input=false

              if ($action -eq "DESTROY") {
                terraform plan  -destroy -out=tfplan -no-color -input=false
                terraform apply -no-color -input=false -auto-approve tfplan
              } elseif ($action -eq "APPLY") {
                terraform plan  -out=tfplan -no-color -input=false
                terraform apply -no-color -input=false -auto-approve tfplan
                terraform output
                terraform output -no-color -json | Out-File -FilePath tf-outputs.json -Encoding utf8
              } else { throw "Unsupported TF_ACTION: $action" }
            '''
          }
        }
      }
    }
  }

  post {
    always {
      archiveArtifacts artifacts: "${TF_DIR}\\tfplan, ${TF_DIR}\\tf-outputs.json", allowEmptyArchive: true
      cleanWs()
    }
  }
}
