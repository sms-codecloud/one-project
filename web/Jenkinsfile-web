pipeline {
  agent { label 'win-dev' }
  options { disableConcurrentBuilds(); timestamps() }

  parameters {
    string( name: 'AWS_REGION',        defaultValue: 'ap-south-1',      description: 'AWS region')
    string( name: 'EC2_INSTANCE_ID',   defaultValue: '',                description: 'Target Windows EC2 (from infra outputs)')
    string( name: 'ARTIFACT_BUCKET',   defaultValue: 'arj-bootcamp',    description: 'S3 bucket for deploy artifacts')
    string( name: 'APP_REL_PATH',      defaultValue: 'web',             description: 'Relative path to React app folder')
    string( name: 'APP_NAME',          defaultValue: 'student-web',     description: 'Bundle name prefix')
    choice( name: 'NODE_MODE',         choices: ['production','development'], description: 'NODE_ENV for runtime (build step forces dev for tooling)')
    // Optional: wire your React app to the IIS-hosted .NET API
    string( name: 'API_BASE_URL',      defaultValue: '',                description: 'Optional API base (e.g. http://localhost:5000 or https://site/api)')
    string( name: 'IIS_SITE_NAME',     defaultValue: 'one-project',     description: 'IIS site name on EC2')
    string( name: 'IIS_SITE_ROOT',     defaultValue: 'C:\\deploy\\web', description: 'IIS site physical path on EC2')
  }

  environment {
    NODE_ENV = "${params.NODE_MODE}"
    PATH     = "C:\\Program Files\\nodejs;C:\\Program Files\\Amazon\\AWSCLIV2;${env.PATH}"
    FORCED_WS = 'D:\\jenkins-workspace\\workspace'
  }

  stages {
    stage('Checkout (forced workspace)') {
      steps {
        ws("${env.FORCED_WS}") {
          deleteDir()
          checkout scm
          bat 'cd & dir /b'
        }
      }
    }

    stage('Prepare env (optional API base)') {
      when { expression { return params.API_BASE_URL?.trim() } }
      steps {
        ws("${env.FORCED_WS}") {
          dir("${params.APP_REL_PATH}") {
            // For Vite-style env vars; adjust if you use CRA or custom
            writeFile file: '.env.production', text: "VITE_API_BASE_URL=${params.API_BASE_URL}\r\n"
            echo "Wrote .env.production with VITE_API_BASE_URL=${params.API_BASE_URL}"
          }
        }
      }
    }

    stage('Install & Build (local)') {
      steps {
        ws("${env.FORCED_WS}") {
          dir("${params.APP_REL_PATH}") {
            // Force devDeps present so vite/webpack/build tools exist
            withEnv(['NODE_ENV=development','NPM_CONFIG_PRODUCTION=false']) {
              bat 'cmd /c node -v'
              bat 'cmd /c npm -v'
              bat 'cmd /c if exist package-lock.json (npm ci --include=dev) else (npm install)'
              bat 'cmd /c npm run build'
            }

            // Zip the build output (supports Vite=dist or CRA=build)
            bat '''
              if exist dist ( set "BUILD_DIR=dist" ) else ( set "BUILD_DIR=build" )
              for /f "tokens=* delims= " %%A in ("%BUILD_DIR%") do set "BUILD_DIR=%%~A"
              echo BUILD_DIR=[%BUILD_DIR%]
              if not exist "%BUILD_DIR%" ( echo ERROR: No dist/ or build/ folder.& exit /b 2 )
              if exist web.zip del /q web.zip
              powershell -NoProfile -ExecutionPolicy Bypass -Command ^
                "$bd = $env:BUILD_DIR.Trim(); Compress-Archive -Path (Join-Path $bd '*') -DestinationPath web.zip -Force"
              dir web.zip
            '''
            archiveArtifacts artifacts: 'web.zip', fingerprint: true
          }
        }
      }
    }

    stage('Upload to S3') {
      steps {
        ws("${env.FORCED_WS}") {
          withCredentials([[$class:'AmazonWebServicesCredentialsBinding', credentialsId:'aws_secrets_shankar']]) {
            dir("${params.APP_REL_PATH}") {
              script {
                def key = "web/${params.APP_NAME}-${env.BUILD_NUMBER}.zip"
                bat "aws s3 cp web.zip s3://${params.ARTIFACT_BUCKET}/${key} --region ${params.AWS_REGION}"
                env.S3_KEY = key
                echo "Uploaded: s3://${params.ARTIFACT_BUCKET}/${key}"
              }
            }
          }
        }
      }
    }

    stage('Deploy to EC2 via SSM (IIS swap)') {
      when { expression { return params.EC2_INSTANCE_ID?.trim() } }
      steps {
        ws("${env.FORCED_WS}") {
          withCredentials([[$class:'AmazonWebServicesCredentialsBinding', credentialsId:'aws_secrets_shankar']]) {
            script {
              // --- PS script that runs on EC2 Windows host ---
              def ps = """
\$ErrorActionPreference = 'Stop'
aws --version | Out-Null

\$bucket='${params.ARTIFACT_BUCKET}'
\$key='${env.S3_KEY}'
\$zip='C:\\\\deploy\\\\incoming\\\\web.zip'
\$temp='C:\\\\deploy\\\\incoming\\\\web_unzip'
\$siteRoot='${params.IIS_SITE_ROOT.replace('\\','\\\\')}'
\$siteName='${params.IIS_SITE_NAME}'

New-Item -ItemType Directory -Force -Path (Split-Path \$zip) | Out-Null
New-Item -ItemType Directory -Force -Path \$siteRoot | Out-Null

if (Test-Path \$zip) { Remove-Item \$zip -Force }
aws s3 cp "s3://\$bucket/\$key" \$zip --region ${params.AWS_REGION}

if (Test-Path \$temp) { Remove-Item \$temp -Recurse -Force }
New-Item -ItemType Directory -Force -Path \$temp | Out-Null
Add-Type -AssemblyName System.IO.Compression.FileSystem
[System.IO.Compression.ZipFile]::ExtractToDirectory(\$zip, \$temp)

Import-Module WebAdministration
if (Get-Website -Name \$siteName -ErrorAction SilentlyContinue) {
  Stop-WebSite -Name \$siteName -ErrorAction SilentlyContinue
}

if (Test-Path \$siteRoot) {
  Get-ChildItem -Path \$siteRoot -Force | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
} else {
  New-Item -ItemType Directory -Force -Path \$siteRoot | Out-Null
}

Copy-Item "\$temp\\*" \$siteRoot -Recurse -Force

if (Get-Website -Name \$siteName -ErrorAction SilentlyContinue) {
  Start-WebSite -Name \$siteName
} else {
  New-Website -Name \$siteName -PhysicalPath \$siteRoot -Port 80 -Force
}

Write-Host "Deployed static site to \$siteRoot"
""".trim()

              // Build {"commands":[...]} JSON for SSM cleanly
              def lines   = ps.split(/\r?\n/)
              def escaped = lines.collect { it.replace("\\", "\\\\").replace("\"", "\\\"") }
              def json    = '{"commands":["' + escaped.join('","') + '"]}'
              writeFile file: 'params.json', text: json

              // Send & capture CommandId cleanly
              def cmdId = bat(
                returnStdout: true,
                script: """
                  aws ssm send-command ^
                    --instance-ids ${params.EC2_INSTANCE_ID} ^
                    --document-name AWS-RunPowerShellScript ^
                    --parameters file://params.json ^
                    --region ${params.AWS_REGION} ^
                    --cli-binary-format raw-in-base64-out ^
                    --query "Command.CommandId" --output text
                """
              ).trim()
              echo "SSM CommandId=${cmdId}"

              // Poll status
              String status = ''
              int maxLoops = 60
              for (int i = 0; i < maxLoops; i++) {
                status = bat(
                  returnStdout: true,
                  script: "aws ssm list-commands --command-id ${cmdId} --region ${params.AWS_REGION} --query \"Commands[0].Status\" --output text"
                ).trim()
                echo "SSM status: ${status}"
                if (['Success','Failed','TimedOut','Cancelled'].contains(status)) break
                sleep time: 5, unit: 'SECONDS'
              }

              // Fetch output
              def ssmOut = bat(
                returnStdout: true,
                script: """
                  aws ssm get-command-invocation ^
                    --command-id ${cmdId} ^
                    --instance-id ${params.EC2_INSTANCE_ID} ^
                    --region ${params.AWS_REGION} ^
                    --query "StandardOutputContent" --output text
                """
              )
              def ssmErr = bat(
                returnStdout: true,
                script: """
                  aws ssm get-command-invocation ^
                    --command-id ${cmdId} ^
                    --instance-id ${params.EC2_INSTANCE_ID} ^
                    --region ${params.AWS_REGION} ^
                    --query "StandardErrorContent" --output text
                """
              )

              echo "----- SSM STDOUT -----\n${ssmOut}"
              if (ssmErr?.trim()) echo "----- SSM STDERR -----\n${ssmErr}"

              if (status != 'Success') {
                error "SSM command ${cmdId} completed with status=${status}"
              }
            }
          }
        }
      }
    }
  }

  post {
    success { echo "Web deployed to IIS on Windows EC2 (t2.micro) via SSM." }
    always  { echo "Done. Workspace used: ${env.FORCED_WS}" }
  }
}
